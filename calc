#!/usr/bin/env perl

use strict;
use warnings;

sub parse_opts {
  my (%opts, @otherOpts, @stdin);

  my $curOpt;
  for (@_) {
    if (/^-.*$/) {
      $curOpt = $_;
      $opts{$curOpt} = undef;
    }
    elsif (defined $curOpt) {
      $opts{$curOpt} = $_;
      undef $curOpt;
    }
    else {
      push @otherOpts, $_;
    }
  }

  @stdin = <STDIN> if exists $opts{"-"};

  return \%opts, \@otherOpts, \@stdin;
}

#Parse arguments
my @opts = parse_opts(@ARGV);
my %args = %{$opts[0]};
my @otherArgs = @{$opts[1]};
my @stdin = @{$opts[2]};

#If input file is provided, read it as STDIN
if (!@stdin && @otherArgs) {
  my $fname = $otherArgs[0];
  my $fh;
  open $fh, "<", $fname or die "File $fname does not exist.";
  @stdin = <$fh>;
  close $fh;
}

#If input file is not provided, try pipe
if (!@stdin && !-t STDIN) {
  @stdin = <STDIN>;
}

#Load expressions
my @expr = grep {length} split /[,;\n]/m, $args{"-e"} || join("\n", @stdin);
#my @expr = @ARGV ? @ARGV : <STDIN>;

#Line by line evaluation
my $result;
if (@expr) {
  for (@expr) {
    my $orig = $_;
    s/_/\$result/mg;
    $result = eval;
    print $orig, "\t", $result, "\n";
  }
}
elsif (!@stdin && !exists $args{"-"}){
  my $count = 1;
  my $get_prompt = sub {
    return "[EXPR " . $count++ . "] ";
  };

  print &{$get_prompt};
  while (<STDIN>) {
    s/_/\$result/mg;
    $result = eval;
    print "=>" . ($result || "") . "\n" . &{$get_prompt};
  } 
}
